# Приложение - список покупок
Это приложение - тестовое задание, для вакансии Junior-developer KMP(kotlin multiplatform)
## Описание приложения:
Приложение представляет собой kmp-проект, который на данный момент запускается и работает на следующих платформах: *Android*, *Windows*, *IOS*
Приложение служит для работы со списком покупок в **онлайн** режиме, и полностью реализует весь функционал, предназначенный для реализации сайтом https://cyberprot.ru/shopping/v2/
## Реализованный функционал:
- Генерация ключа
- Добавление ключа
- Удаление ключа
- Запоминание всех созданных ключей
- Создание списка покупок
- Удаление списка покупок
- Загрузка списков покупок по ключу
- Добавление предмета в список покупок
- Удаление предмета из списка покупок
- Вычеркивание объекта
- Обновление данных по клику
  >Связано с тем, что сервер не работает через websocket и поэтому невозможно узнать об изменении данных, не дав запрос серверу
- Редактирование настроек (автооткрытие списков, спрашивать или нет подтверждение удаления)
## Использованные технологии и навыки
В этом пункте представлено подробное описание всех использованных навыков и технологий
### Технологии
1) `JetpackCompose` - реактивный UI фреймворк, позволяющий более удобно создавать UI, основанный на снапшотах(стейты), и автоматически пересчитывающийся(только необходимое) при изменении стейтов
2) `Koin` - DI фреймворк, позволяющий через модули и внутренние инстансы реализовывать граф, позволяющий решить зависимости и инъектировать необходимые данные из data-модулей в feature-модули. Используется как синглтон, обладающей тотальной информацией о резолвинге зависимостей. Использует platform-модули, которые полиморфически реализуются каждой отдельной платформой, и shared-модули, предоставляющие зависимости для общих информационных сущностей
3) `Ktor` - REST+WS фреймворк, позволяющий удобно обращаться к эндпоинтам сервера, используя HTTP-запросы, или websocket-сессии
4) `Room`(multiplatform) - Фреймворк, представляющий из себя надстройку над базой данных SQLite, позволяющий удобным образом, через аннотации, изменять данные в базе данных. Так же достоинством этого фреймворка является возможность получить данные как реактивный flow, так, что при их изменении, в этот StateFlow произойдет emit новых данных, что позволяет из feature-модуля в корутине начать collect этого flow, с последующим обновлением composable state или еще одного StateFlow, созданного, как возможный вариант, методом stateIn(), с целью использования в дальнейшем операторов
5) `DataStorage` - multiplatform библиотека, позволяющая хранить данные любого вида, и сохранять их между запусками приложения. В Проекте используется для реализации настроек приложения
### Навыки
1) Разделение на слои *UI*, *DOMAIN*, *DATA*.

   *UI* слой - это все, что связано с UI и с UI-логикой, например анимациями, скролл-стейтами, отображением snackbar, навигацией и тд.
   > Представляется **App**, **Feature**, **Core** модулями
   
   *DOMAIN* слой - все, что связано с бизнес-логикой, с обработкой данных, введенных пользователем, и обработкой полученных данных со стороны *DATA* слоя.
   > Представляется **Feature**, **Core** модулями
   
   *DATA* слой - все, что связано с предоставлением данных в удобном виде.
   > Полностью представляет собой совокупность всех **DATA**-модулей
2) Использование MVVM-архитектурого паттерна.

   *Model* - то, что отвечает за данные, по сути это *DATA* репозитории, которые инжектятся во `ViewModel` в конкретной фиче
   
   *View*- то, что отвечает в **Feature** модуле за UI, в Проекте представляет собой все `@Composable` функции конкретной фичи
   
   *ViewModel* - то, что отвечает за связь между UI и DATA, относится к DOMAIN слою, представляет собой `ViewModel`, создаваемую из UI, в Проекте создается с помощью функции koinViewModel<>()
3) Многомодульность
   > Однако по факту здесь ее нет, вместо нее просто разбиение на пакеты, создающую полную или почти логическую интерпретацию многомодульности в **Android**.
   
   Использование модулей 4 типов: **App**, **Feature**, **Data**, **Core**

   **App** - модуль, представляющий собой точку входа в приложение, занимающийся построением навигационного UI и навигацией между **Feature** модулями. Может включать в себя **Feature**, **Core**, **Data** модули
   
   **Feature** - модуль, представляющий собой конкретный экран или множество экранов данного приложения. **Feature** модуль не имеет право знать об **App** модулях или об других **Feature** модуля. Может включать в себя **Data** и **Core** модули
   
   **Data** - модуль, представляющий собой конкретное множество классов данных, а так же систему предоставления и редактирования данных (*Repository*). Может знать о **Data** и **Core** модулях
   
   **Core** - модуль, предоставляющий *общие* полезные утилиты, которые относятся к слоям(Domain, UI). Может включать в себя только **Core** модули, но обычно используется в одиночку
4) Мультиплатформенность
   позволяет писать кроссплатформенный код на kotlin, который работает на большинстве платформ, и напоминает собой наследование классов. Здесь же идет речь и о словах `Expect`/`Actual`. Это - аналог полиморфизма в ООП.
## Скриншоты
![изображение](https://github.com/user-attachments/assets/53325950-dbc4-4e9a-9c90-b1a3ab303142)

Фича 1 - просмотр товаров

![изображение](https://github.com/user-attachments/assets/680d0cd6-680a-4f65-b410-98f34bfa794d)

Фича 1 - подтверждение для удаления товара

![изображение](https://github.com/user-attachments/assets/69330ee5-4112-40ee-af00-0cf972a2112b)

Фича 1 - подтверждение для удаления списка

![изображение](https://github.com/user-attachments/assets/4bbf558f-99ed-4f01-ad14-9b7807fe7bc9)

Фича 1 - добавление товара в список

![изображение](https://github.com/user-attachments/assets/2fa84b57-1d2d-4820-a732-75287555fbbb)

Фича 1 - создание списка

![изображение](https://github.com/user-attachments/assets/dace011c-4aa8-491d-9a1a-f81e4278dad9)

Фича1 - не выбран ключ

![изображение](https://github.com/user-attachments/assets/649ac753-e6fe-4880-9e68-3833d5bb9fbf)

Фича 2 - не выбран ключ

![изображение](https://github.com/user-attachments/assets/8852b2e3-fa69-416b-87ee-5b243de3d0f4)

Фича 2 - выбран ключ

![изображение](https://github.com/user-attachments/assets/cefe0303-6285-41cb-8d8c-30db02bcec29)

Фича 2 - создание ключа

![изображение](https://github.com/user-attachments/assets/0f5a1f97-4ee8-4630-8ce5-60e1d4f06f43)

Фича 2 - добавление существующего ключа

![изображение](https://github.com/user-attachments/assets/85bb9d0c-d832-4458-b138-cf24de14e242)

Фича 2 - подтверждение удаления ключа

![изображение](https://github.com/user-attachments/assets/7b97924d-b0dc-45ac-acb3-b43275241dd8)

Фича 3 - настройки

# Спасибо что досмотрел(а) до конца. Я старался
